{"version":3,"sources":["../../src/algos/BFS.js"],"names":["BFS","graph","opts","options","flagKey","clearFlags","forEachVertex","v","mark","isMarked","defaultTraversalOptions","direction","OUT","onVisit","u","onTestEdge","e","edgeFilter","traverse","source","queue","push","edges","length","shift","incidentEdges","forEach","to","from"],"mappings":";;;;;;;;AAAA;;AAEA,SAASA,GAAT,CAAaC,KAAb,EAAoBC,IAApB,EAA0B;AACtB,QAAMC,UAAU,SAAc,EAAEC,SAAS,MAAX,EAAd,EAAmCF,IAAnC,CAAhB;AACA,QAAME,UAAUD,QAAQC,OAAxB;;AAEA,aAASC,UAAT,GAAsB;AAClBJ,cAAMK,aAAN,CAAoB,UAASC,CAAT,EAAY;AAC5B,mBAAOA,EAAEH,OAAF,CAAP;AACH,SAFD;AAGH;;AAED,aAASI,IAAT,CAAcD,CAAd,EAAiB;AACbA,UAAEH,OAAF,IAAa,IAAb;AACH;;AAED,aAASK,QAAT,CAAkBF,CAAlB,EAAqB;AACjB,eAAOA,EAAEH,OAAF,MAAe,IAAtB;AACH;;AAED,QAAMM,0BAA0B;AAC5BC,mBAAWC,cADiB;AAE5BC,iBAAS,iBAASC,CAAT,EAAY,CAAG,CAFI;AAG5BC,oBAAY,oBAASC,CAAT,EAAY,CAAG,CAHC;AAI5BC,oBAAY,IAJgB,CAIR;AAJQ,KAAhC;;AAOA,WAAO;AACH;;;;AAIAC,gBALG,oBAKMC,MALN,EAKcjB,IALd,EAKoB;AACnB,gBAAMC,UAAU,SAAc,EAAd,EAAkBO,uBAAlB,EAA2CR,IAA3C,CAAhB;;AAEAG;;AAEA,gBAAMe,QAAQ,EAAd;AACAA,kBAAMC,IAAN,CAAWF,MAAX;AACAX,iBAAKW,MAAL,EAAa,IAAb;AACA,gBAAIL,UAAJ;AAAA,gBAAOP,UAAP;AAAA,gBAAUe,cAAV;;AAEA,mBAAMF,MAAMG,MAAN,GAAe,CAArB,EAAwB;AACpBT,oBAAIM,MAAMI,KAAN,EAAJ;AACArB,wBAAQU,OAAR,CAAgBC,CAAhB;AACAQ,wBAAQrB,MAAMwB,aAAN,CAAoBX,CAApB,EAAuBX,QAAQQ,SAA/B,EAA0CR,QAAQc,UAAlD,CAAR;AACAK,sBAAMI,OAAN,CAAc,UAASV,CAAT,EAAY;AACtBb,4BAAQY,UAAR,CAAmBC,CAAnB;AACAT,wBAAIJ,QAAQQ,SAAR,GAAoBK,EAAEW,EAAtB,GAA2BX,EAAEY,IAAjC;AACA,wBAAG,CAACnB,SAASF,CAAT,CAAJ,EAAiB;AACbC,6BAAKD,CAAL;AACAa,8BAAMC,IAAN,CAAWd,CAAX;AACH;AACJ,iBAPD;AAQH;AACJ;AA5BE,KAAP;AA8BH;;kBAEcP,G","file":"BFS.js","sourcesContent":["import { OUT } from '../core/constants.js';\n\nfunction BFS(graph, opts) {\n    const options = Object.assign({ flagKey: '_bfs' }, opts);\n    const flagKey = options.flagKey;\n\n    function clearFlags() {\n        graph.forEachVertex(function(v) {\n            delete v[flagKey];\n        });\n    }\n\n    function mark(v) {\n        v[flagKey] = true;\n    }\n\n    function isMarked(v) {\n        return v[flagKey] === true;\n    }\n\n    const defaultTraversalOptions = {\n        direction: OUT,\n        onVisit: function(u) { },\n        onTestEdge: function(e) { },\n        edgeFilter: null    // take all edges\n    };\n\n    return {\n        /**\n        Traverse the graph using the breadth first algorithm,\n        starting from source, with the specified options\n        */\n        traverse(source, opts) {\n            const options = Object.assign({}, defaultTraversalOptions, opts);\n\n            clearFlags();\n\n            const queue = [];\n            queue.push(source);\n            mark(source, null);\n            let u, v, edges;\n\n            while(queue.length > 0) {\n                u = queue.shift();\n                options.onVisit(u);\n                edges = graph.incidentEdges(u, options.direction, options.edgeFilter);\n                edges.forEach(function(e) {\n                    options.onTestEdge(e);\n                    v = options.direction ? e.to : e.from;\n                    if(!isMarked(v)) {\n                        mark(v);\n                        queue.push(v);\n                    }\n                });\n            }\n        }\n    };\n}\n\nexport default BFS;\n"]}