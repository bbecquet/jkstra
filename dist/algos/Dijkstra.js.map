{"version":3,"sources":["../../src/algos/Dijkstra.js"],"names":["Dijkstra","graph","opts","options","flagKey","nodeFlagger","NodeFlagger","end","edges","edge","getFlags","inc","push","from","reverse","source","target","isFinished","state","SETTLED","found","traverse","rebuildPath","defaultTraversalOptions","dijkstraIterator","DijkstraIterator","next","done"],"mappings":";;;;;;;;;;AAAA;;;;AACA;;;;AACA;;;;;;IAEMA,Q;AACF,sBAAYC,KAAZ,EAAmBC,IAAnB,EAAyB;AAAA;;AACrB,aAAKD,KAAL,GAAaA,KAAb;AACA,aAAKE,OAAL,GAAe,SAAc,EAAEC,SAAS,WAAX,EAAd,EAAwCF,IAAxC,CAAf;AACA,aAAKG,WAAL,GAAmB,IAAIC,qBAAJ,CAAgB,KAAKL,KAArB,EAA4B,KAAKE,OAAL,CAAaC,OAAzC,CAAnB;AACH;;;;oCAEWG,G,EAAK;AACb,gBAAMC,QAAQ,EAAd;AACA,gBAAIC,aAAJ;AACA;AACA,mBAAO,CAACA,OAAO,KAAKJ,WAAL,CAAiBK,QAAjB,CAA0BH,GAA1B,EAA+BI,GAAvC,MAAgD,IAAvD,EAA6D;AACzDH,sBAAMI,IAAN,CAAWH,IAAX;AACAF,sBAAME,KAAKI,IAAX;AACH;AACD,mBAAOL,MAAMM,OAAN,EAAP;AACH;;;;;AAMD;;;qCAGaC,M,EAAQC,M,EAAQd,I,EAAM;AAAA;;AAC/B,gBAAMC,UAAUD,QAAQ,EAAxB;AACAC,oBAAQc,UAAR,GAAqB;AAAA,uBAAM,MAAKZ,WAAL,CAAiBK,QAAjB,CAA0BM,MAA1B,EAAkCE,KAAlC,KAA4CC,kBAAlD;AAAA,aAArB;;AAEA,gBAAMC,QAAQ,KAAKC,QAAL,CAAcN,MAAd,EAAsBZ,OAAtB,CAAd;AACA,gBAAGiB,KAAH,EAAU;AACN,uBAAO,KAAKE,WAAL,CAAiBN,MAAjB,CAAP;AACH;AACD,mBAAO,IAAP;AACH;;AAED;;;;;;;iCAISD,M,EAAQb,I,EAAM;AACnB,gBAAMC,UAAU,SAAc,EAAd,EAAkBH,SAASuB,uBAA3B,EAAoDrB,IAApD,CAAhB;AACA,gBAAMsB,mBAAmB,IAAIC,0BAAJ,CAAqB,KAAKxB,KAA1B,EAAiCc,MAAjC,EAAyCb,IAAzC,CAAzB;;AAEA;AACA,mBAAM,CAACsB,iBAAiBE,IAAjB,GAAwBC,IAAzB,IAAiC,CAACxB,QAAQc,UAAR,EAAxC,EAA8D,CAAG;;AAEjE;AACA,mBAAOd,QAAQc,UAAR,EAAP;AACH;;;;;;AAjDCjB,Q,CAkBKuB,uB,GAA0B;AAC7BN,gBAAY;AAAA,eAAM,KAAN;AAAA,KADiB,E;AAgCpC;;kBAEcjB,Q","file":"Dijkstra.js","sourcesContent":["import DijkstraIterator from '../algos/DijkstraIterator.js';\nimport NodeFlagger from './nodeFlagger.js';\nimport { SETTLED } from '../core/constants.js';\n\nclass Dijkstra {\n    constructor(graph, opts) {\n        this.graph = graph;\n        this.options = Object.assign({ flagKey: '_dijkstra' }, opts);\n        this.nodeFlagger = new NodeFlagger(this.graph, this.options.flagKey);\n    }\n\n    rebuildPath(end) {\n        const edges = [];\n        let edge;\n        // going upward in the tree until the first vertex (with no incoming edge)\n        while ((edge = this.nodeFlagger.getFlags(end).inc) !== null) {\n            edges.push(edge);\n            end = edge.from;\n        }\n        return edges.reverse();\n    }\n\n    static defaultTraversalOptions = {\n        isFinished: () => false\n    }\n\n    /**\n    The most common use of Dijkstra traversal\n    */\n    shortestPath(source, target, opts) {\n        const options = opts || {};\n        options.isFinished = () => this.nodeFlagger.getFlags(target).state === SETTLED;\n\n        const found = this.traverse(source, options);\n        if(found) {\n            return this.rebuildPath(target);\n        }\n        return null;\n    }\n\n    /**\n    Traverse the graph using Dijkstra's algorithm,\n    starting from source, with the specified options\n    */\n    traverse(source, opts) {\n        const options = Object.assign({}, Dijkstra.defaultTraversalOptions, opts);\n        const dijkstraIterator = new DijkstraIterator(this.graph, source, opts);\n\n        // simply loop over the iterator until it ends\n        while(!dijkstraIterator.next().done && !options.isFinished()) { }\n\n        // if false, means the whole graph was traversed\n        return options.isFinished();\n    }\n};\n\nexport default Dijkstra;\n"]}