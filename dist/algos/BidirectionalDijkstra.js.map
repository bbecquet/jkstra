{"version":3,"sources":["../../src/algos/BidirectionalDijkstra.js"],"names":["BidirectionalDijkstra","graph","opts","options","outKey","inKey","meetingNode","edges","edge","currentNode","outFlagger","getFlags","inc","push","from","reverse","inFlagger","to","node","outState","inState","state","REACHED","SETTLED","source","target","outIteraror","DijkstraIterator","OUT","direction","flagKey","inIterator","IN","NodeFlagger","iterator","next","done","_hasBeenReachBothWays","value","rebuildPath"],"mappings":";;;;;;;;;;AAAA;;;;AACA;;;;AACA;;;;;;IAEMA,qB;AACF,mCAAYC,KAAZ,EAAmBC,IAAnB,EAAyB;AAAA;;AACrB,aAAKD,KAAL,GAAaA,KAAb;AACA,aAAKE,OAAL,GAAe,SAAc,EAAd,EAAkBD,IAAlB,CAAf;AACA,aAAKE,MAAL,GAAc,eAAd;AACA,aAAKC,KAAL,GAAa,cAAb;AACH;;;;oCAEWC,W,EAAa;AACrB,gBAAMC,QAAQ,EAAd;AACA,gBAAIC,aAAJ;AACA,gBAAIC,cAAcH,WAAlB;AACA;AACA,mBAAO,CAACE,OAAO,KAAKE,UAAL,CAAgBC,QAAhB,CAAyBF,WAAzB,EAAsCG,GAA9C,MAAuD,IAA9D,EAAoE;AAChEL,sBAAMM,IAAN,CAAWL,IAAX;AACAC,8BAAcD,KAAKM,IAAnB;AACH;AACDP,kBAAMQ,OAAN;AACAN,0BAAcH,WAAd;AACA;AACA,mBAAO,CAACE,OAAO,KAAKQ,SAAL,CAAeL,QAAf,CAAwBF,WAAxB,EAAqCG,GAA7C,MAAsD,IAA7D,EAAmE;AAC/DL,sBAAMM,IAAN,CAAWL,IAAX;AACAC,8BAAcD,KAAKS,EAAnB;AACH;AACD,mBAAOV,KAAP;AACH;;;8CAEqBW,I,EAAM;AACxB,gBAAMC,WAAW,KAAKT,UAAL,CAAgBC,QAAhB,CAAyBO,IAAzB,CAAjB;AACA,gBAAME,UAAU,KAAKJ,SAAL,CAAeL,QAAf,CAAwBO,IAAxB,CAAhB;;AAEA,mBAAO,CAACC,SAASE,KAAT,KAAmBC,kBAAnB,IAA8BH,SAASE,KAAT,KAAmBE,kBAAlD,MACCH,QAAQC,KAAR,KAAkBC,kBAAlB,IAA6BF,QAAQC,KAAR,KAAkBE,kBADhD,CAAP;AAEH;;;qCAEYC,M,EAAQC,M,EAAQtB,O,EAAS;AAClC,gBAAMuB,cAAc,IAAIC,0BAAJ,CAAqB,KAAK1B,KAA1B,EAAiCuB,MAAjC,EAChB,SAAc,EAAd,EACIrB,OADJ,EAEIA,QAAQyB,GAFZ,EAGI,EAAEC,WAAWD,cAAb,EAAkBE,SAAS,KAAK1B,MAAhC,EAHJ,CADgB,CAApB;AAMA,gBAAM2B,aAAa,IAAIJ,0BAAJ,CAAqB,KAAK1B,KAA1B,EAAiCwB,MAAjC,EACf,SAAc,EAAd,EACItB,OADJ,EAEIA,QAAQ6B,EAFZ,EAGI,EAAEH,WAAWG,aAAb,EAAiBF,SAAS,KAAKzB,KAA/B,EAHJ,CADe,CAAnB;AAMA,iBAAKK,UAAL,GAAkB,IAAIuB,qBAAJ,CAAgB,KAAKhC,KAArB,EAA4B,KAAKG,MAAjC,CAAlB;AACA,iBAAKY,SAAL,GAAiB,IAAIiB,qBAAJ,CAAgB,KAAKhC,KAArB,EAA4B,KAAKI,KAAjC,CAAjB;;AAEA,gBAAI6B,WAAWR,WAAf;AACA,gBAAIpB,oBAAJ;AACA,gBAAI6B,aAAJ;;AAEA;AACA,mBAAO,CAAC,CAACA,OAAOD,SAASC,IAAT,EAAR,EAAyBC,IAAjC,EAAuC;AACnC,oBAAG,KAAKC,qBAAL,CAA2BF,KAAKG,KAAhC,CAAH,EAA2C;AACvChC,kCAAc6B,KAAKG,KAAnB;AACA;AACH;AACD;AACAJ,2BAAWA,aAAaR,WAAb,GAA2BK,UAA3B,GAAwCL,WAAnD;AACH;;AAED,gBAAIpB,WAAJ,EAAiB;AACb,uBAAO,KAAKiC,WAAL,CAAiBjC,WAAjB,CAAP;AACH;AACD,mBAAO,IAAP;AACH;;;;;;AACJ;;kBAEcN,qB","file":"BidirectionalDijkstra.js","sourcesContent":["import DijkstraIterator from '../algos/DijkstraIterator.js';\nimport NodeFlagger from './nodeFlagger.js';\nimport { IN, OUT, REACHED, SETTLED } from '../core/constants.js';\n\nclass BidirectionalDijkstra {\n    constructor(graph, opts) {\n        this.graph = graph;\n        this.options = Object.assign({}, opts);\n        this.outKey = '_dijkstra_out';\n        this.inKey = '_dijkstra_in';\n    }\n\n    rebuildPath(meetingNode) {\n        const edges = [];\n        let edge;\n        let currentNode = meetingNode;\n        // going upward in the tree until the first vertex (with no incoming edge)\n        while ((edge = this.outFlagger.getFlags(currentNode).inc) !== null) {\n            edges.push(edge);\n            currentNode = edge.from;\n        }\n        edges.reverse();\n        currentNode = meetingNode;\n        // going upward in the tree until the first vertex (with no incoming edge)\n        while ((edge = this.inFlagger.getFlags(currentNode).inc) !== null) {\n            edges.push(edge);\n            currentNode = edge.to;\n        }\n        return edges;\n    }\n\n    _hasBeenReachBothWays(node) {\n        const outState = this.outFlagger.getFlags(node);\n        const inState = this.inFlagger.getFlags(node);\n\n        return (outState.state === REACHED || outState.state === SETTLED)\n            && (inState.state === REACHED || inState.state === SETTLED);\n    }\n\n    shortestPath(source, target, options) {\n        const outIteraror = new DijkstraIterator(this.graph, source,\n            Object.assign({},\n                options,\n                options.OUT,\n                { direction: OUT, flagKey: this.outKey })\n        );\n        const inIterator = new DijkstraIterator(this.graph, target,\n            Object.assign({},\n                options,\n                options.IN,\n                { direction: IN, flagKey: this.inKey })\n        );\n        this.outFlagger = new NodeFlagger(this.graph, this.outKey);\n        this.inFlagger = new NodeFlagger(this.graph, this.inKey);\n\n        let iterator = outIteraror;\n        let meetingNode;\n        let next;\n\n        // simply loop over the iterator until it ends\n        while (!(next = iterator.next()).done) {\n            if(this._hasBeenReachBothWays(next.value)) {\n                meetingNode = next.value;\n                break;\n            }\n            // alternate between the two iterators\n            iterator = iterator === outIteraror ? inIterator : outIteraror;\n        }\n\n        if (meetingNode) {\n            return this.rebuildPath(meetingNode);\n        }\n        return null;\n    }\n};\n\nexport default BidirectionalDijkstra;\n"]}