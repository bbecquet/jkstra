{"version":3,"sources":["../../src/algos/DijkstraIterator.js"],"names":["DijkstraIterator","graph","source","opts","options","defaultOptions","flags","NodeFlagger","flagKey","pQ","PriorityQueue","_initTraversal","v","incEdge","fCost","gCost","action","setFlags","state","REACHED","inc","SETTLED","clearFlags","insert","heuristic","_reach","onReach","count","done","direction","onSettle","edgeFilter","edgeCost","shouldUpdateKey","u","pop","item","vFlags","uGCost","getFlags","vFCost","vGCost","_settle","edges","incidentEdges","e","OUT","to","from","updateKey","value","prevCost","newCost","costDone"],"mappings":"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","file":"DijkstraIterator.js","sourcesContent":["import PriorityQueue from 'updatable-priority-queue';\nimport NodeFlagger from './nodeFlagger.js';\nimport { OUT, SETTLED, REACHED } from '../core/constants.js';\n\nclass DijkstraIterator {\n    static defaultOptions = {\n        flagKey: '_dijkstra',\n        direction: OUT,\n        shouldUpdateKey: (prevCost, newCost) => { return newCost < prevCost; },\n        edgeCost: (e, costDone) => 1,\n        heuristic: v => 0,\n        onReach: null,        // nothing special to do when reaching a node\n        onSettle: null,     // nothing special to do when setting a node\n        edgeFilter: null    // take all edges\n    }\n\n    constructor(graph, source, opts) {\n        this.graph = graph;\n        this.source = source;\n        this.options = Object.assign({}, DijkstraIterator.defaultOptions, opts);\n        this.flags = new NodeFlagger(this.graph, this.options.flagKey);\n\n        this.pQ = new PriorityQueue();\n        this._initTraversal();\n    }\n\n    _reach(v, incEdge, fCost, gCost, action) {\n        // update state to \"reached\", and register cost and incomingEdge\n        this.flags.setFlags(v, {state: REACHED, fCost, gCost, inc: incEdge});\n        if (action) {\n            action(v);\n        }\n    }\n\n    _settle(v, action) {\n        this.flags.setFlags(v, {state: SETTLED});\n        if (action) {\n            action(v);\n        }\n    }\n\n    _initTraversal() {\n        // reset node tagging\n        this.flags.clearFlags(this.graph);\n        this.pQ.insert(this.source, this.options.heuristic(this.source));\n        this._reach(this.source, null, this.options.heuristic(this.source), 0, this.options.onReach);\n    }\n\n    next() {\n        // if no more node available in the queue,\n        // return the iterator end signal\n        if (this.pQ.count === 0) {\n            return { done: true };\n        }\n\n        const {\n            direction,\n            onReach,\n            onSettle,\n            edgeFilter,\n            edgeCost,\n            heuristic,\n            shouldUpdateKey\n        } = this.options;\n\n        const u = this.pQ.pop().item;\n        let v;\n        let vFlags;\n        const uGCost = this.flags.getFlags(u).gCost;\n        let vFCost, vGCost;\n\n        this._settle(u, onSettle);\n        const edges = this.graph.incidentEdges(u, direction, edgeFilter);\n        for (let e of edges) {\n            v = direction === OUT ? e.to : e.from;\n            vFlags = this.flags.getFlags(v);\n\n            if (vFlags.state !== SETTLED) {\n                vGCost = uGCost + edgeCost(e, uGCost);\n                vFCost = vGCost + heuristic(v);\n                if (vFlags.state !== REACHED) {\n                    this.pQ.insert(v, vFCost);\n                    this._reach(v, e, vFCost, vGCost, onReach);\n                } else {\n                    if (shouldUpdateKey(vFlags.fCost, vFCost, vFlags.inc, e)) {\n                        this.pQ.updateKey(v, vFCost);\n                        this._reach(v, e, vFCost, vGCost, onReach);\n                    }\n                }\n            }\n        }\n\n        return { value: u };\n    }\n};\n\nexport default DijkstraIterator;\n"]}